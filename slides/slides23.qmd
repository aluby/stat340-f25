---
title: Dirichlet + Multinomial Model Case Study
subtitle: Day 23
title-slide-attributes:
  data-background-color: "#e2583eff"
  data-slide-number: none
format: 
  revealjs:
    incremental: false
    scrollable: false
auto-stretch: true
editor_options: 
  chunk_output_type: console
editor: 
  markdown: 
    wrap: 72
execute: 
  warning: false
  message: false
---

```{r}
#| echo: false
#| warning: false
#| message: false

library(countdown)
library(tidyverse)
library(tidybayes)
library(bayesrules)
library(janitor)
library(patchwork)
library(rstan)
library(rstanarm)
library(bayesplot)
library(broom.mixed)
library(ggrepel)

theme_set(theme_minimal(base_size = 16, base_family = "Atkinson Hyperlegible"))
clrs <- viridis::viridis(6, end = .75, option = "plasma")
```

## Dirichlet class assignment example from McElreath

## 

- Do children copy the majority? If so, how does this develop? 
- Problem: can't observe strategy, only choice
- Majority choice is consistent with many strategies

# Data generating process vs GLM

##

```{r}
Boxes <- read_delim("https://raw.githubusercontent.com/rmcelreath/rethinking/refs/heads/master/data/Boxes.csv")

Boxes
```

##

```{r}
ggplot(Boxes, aes(x = majority_first, fill = factor(y))) + 
  geom_bar() +
  scale_fill_viridis_d(end = .75, option = "plasma")
```

## Model setup

## Prior for $p_j$?

## Beta distribution

```{r}
ggplot() +
  stat_function(
    geom = "area", 
    fun = \(x) dbeta(x, shape1 = 3, shape2 = 7), 
    n = 1000, fill = clrs[1]) +
  labs(x = "Probability or proportion", y = NULL, title = "Beta(3, 7)") 
```

## 

```{r}
set.seed(110525)
brms::rdirichlet(n = 10, alpha = c(3, 7)) |> 
    data.frame() |> 
    set_names(1:2) |> 
    mutate(total = `1` + `2`)
```

Dirichlet(3,7) = [Beta(3,7), Beta(7,3)]

## Dirichlet is multivariate Beta

```{r}
brms::rdirichlet(n = 1e5, alpha = c(3, 7)) |> 
    data.frame() |> 
    set_names(c("alpha[1]", "alpha[2]")) |> 
    pivot_longer(everything()) |> 
    ggplot(aes(x = value, fill = name)) +
    geom_density(bounds = c(0, 1), color = NA) +
    scale_fill_manual(values = clrs[c(1, 2)], guide = "none") +
    labs(x = "Probability or proportion", y = NULL, title = "Dirichlet(3, 7)") +
    facet_wrap(vars(name))
```

## Dirichlet is multivariate Beta

```{r}
brms::rdirichlet(n = 3, alpha = c(3, 7, 2)) |> 
    data.frame() |> 
    set_names(1:3) |> 
    mutate(total = `1` + `2` + `3`)
```

```{r}
brms::rdirichlet(n = 3, alpha = c(3, 7, 2, 2, 9, 1)) |> 
    data.frame() |> 
    set_names(1:6) |> 
    mutate(total = `1` + `2` + `3` + `4` + `5` + `6`)
```

## 

```{r}
plot_dirichlet_3_7_2 <- withr::with_seed(1234, {
  brms::rdirichlet(n = 1e5, alpha = c(3, 7, 2)) |> 
    data.frame() |> 
    set_names(paste0("alpha[", 1:3, "]")) |> 
    pivot_longer(everything()) |> 
    ggplot(aes(x = value, fill = name)) +
    geom_density(bounds = c(0, 1), color = NA) +
    scale_x_continuous(breaks = seq(0, 1, by = 0.2)) +
    scale_fill_manual(values = clrs[c(1, 2, 4)], guide = "none") +
    labs(x = "Probability or proportion", y = NULL, title = "Dirichlet(3, 7, 2)") +
    facet_wrap(vars(name), scales = "free_y")
})
plot_dirichlet_3_7_2
```

## Columns are correlated with each other

```{r}
#| echo: false


library(GGally)
points_custom <- function(data, mapping, ...) {
  ggplot(data = data, mapping = mapping, ...) + 
    geom_point(...) + 
    scale_x_continuous(breaks = seq(0, 1, by = 0.2), limits = c(0, 1)) + 
    scale_y_continuous(breaks = seq(0, 1, by = 0.2), limits = c(0, 1)) 
}

dist_custom <- function(data, mapping, ...) {
  ggplot(data = data, mapping = mapping, ...) +
    geom_density(...) +
    aes(fill = "") +
    scale_x_continuous(breaks = seq(0, 1, by = 0.2), limits = c(0, 1)) 
}

cor_custom <- function(data, mapping, ...) {
  ggally_cor(data = data, mapping = mapping, ...) +
    theme_void()
}

scat_mat <- brms::rdirichlet(n = 1e4, alpha = c(3, 7, 2)) |> 
  data.frame() |> 
  set_names(paste0("alpha[", 1:3, "]")) |> 
  ggpairs(
    lower = list(continuous = wrap(points_custom, size = 0.2, alpha = 0.1, color = clrs[5])),
    upper = list(continuous = wrap(cor_custom, family = "Manrope")),
    diag = list(continuous = wrap(dist_custom, color = NA, bounds = c(0, 1)))
  ) +
  labs(title = "Dirichlet(3, 7, 2)", subtitle = "Scatterplot matrix of 1,000 random draws")
scat_mat[1, 1] <- scat_mat[1, 1] + scale_fill_manual(values = clrs[1], guide = "none")
scat_mat[2, 2] <- scat_mat[2, 2] + scale_fill_manual(values = clrs[2], guide = "none")
scat_mat[3, 3] <- scat_mat[3, 3] + scale_fill_manual(values = clrs[4], guide = "none")
scat_mat
```

##

```{r}
#| eval: false
library(ggtern)
# First triangle: random points
withr::with_seed(1234, {
  draws_3_7_2 <- brms::rdirichlet(n = 1e5, alpha = c(3, 7, 2)) |> 
    data.frame() |> 
    set_names(c("x", "y", "z"))
})

tern1 <- draws_3_7_2 |> 
  ggtern(aes(x = x, y = y, z = z)) +
  geom_point(size = 0.2, alpha = 0.1, color = clrs[5]) +
  scale_L_continuous(breaks = 0:5 / 5, labels = 0:5 / 5, name = "α[1]") +
  scale_T_continuous(breaks = 0:5 / 5, labels = 0:5 / 5, name = "α[2]") +
  scale_R_continuous(breaks = 0:5 / 5, labels = 0:5 / 5, name = "α[3]") +
  theme(
    tern.axis.title.L = element_markdown(face = "bold", color = clrs[1], size = rel(1.2)),
    tern.axis.title.T = element_markdown(face = "bold", color = clrs[2], size = rel(1.2)),
    tern.axis.title.R = element_markdown(face = "bold", color = clrs[4], size = rel(1.2))
  )

# Second triangle: actual densities
# Plotting the results from ddirichlet() is more difficult than using dbeta() or
# dnorm() or other univariate distributions. We can't just use geom_function().
# Instead, we need to generate a dataset of all possible combinations of the
# three columns (x, y, and z here), keep only the rows where they sum to one,
# and then find the probability density values for those rows with ddirichlet().
# It's a complex process, but it works :shrug:

# Create a sequence of values for x, y, and z
values <- seq(0, 1, by = 0.005)

# Generate all possible combinations of x, y, and z that sum to 1
df <- expand.grid(x = values, y = values, z = values) |>
  filter(x + y + z == 1) |> 
  rowwise() |>
  mutate(density = pmap_dbl(
    list(x, y, z),
    ~ brms::ddirichlet(
      as.numeric(c(..1, ..2, ..3)),
      alpha = c(3, 7, 2)
    )
  )) |> 
  filter(!is.nan(density))

tern2 <- ggtern(data = df, aes(x = x, y = y, z = z)) +
  geom_point(aes(color = density)) +
  # Mess with the breaks so that the gradient is more visible (basically flatten
  # super high values)
  scale_color_gradientn(
    colors = clrs[5:1], 
    values = scales::rescale(x = c(0, 1, 3, 8, 13), from = c(0, 13)),
    guide = "none"
  ) +
  scale_L_continuous(breaks = 0:5 / 5, labels = 0:5 / 5, name = "α[1]") +
  scale_T_continuous(breaks = 0:5 / 5, labels = 0:5 / 5, name = "α[2]") +
  scale_R_continuous(breaks = 0:5 / 5, labels = 0:5 / 5, name = "α[3]") +
  theme(
    tern.axis.title.L = element_markdown(face = "bold", color = clrs[1], size = rel(1.2)),
    tern.axis.title.T = element_markdown(face = "bold", color = clrs[2], size = rel(1.2)),
    tern.axis.title.R = element_markdown(face = "bold", color = clrs[4], size = rel(1.2))
  )

# ggtern objects don't work with {patchwork} or gridExtra::grid.arrange() or
# {cowplot} or any of the plot-combining packages, but {ggtern} comes with its
# own version of grid.arrange(), so we can use that
ggtern::grid.arrange(tern1, tern2, ncol = 2)
```

## Model

```{stan}
#| output.var: boxes_model
#| echo: true

data{
    int N;
    int y[N];
    int majority_first[N];
}
parameters{
    simplex[5] p;
}
model{
    vector[5] phi;
    
    // prior
    p ~ dirichlet( rep_vector(4,5) );
    
    // probability of data
    for ( i in 1:N ) {
        if ( y[i]==2 ) phi[1]=1; else phi[1]=0; // majority
        if ( y[i]==3 ) phi[2]=1; else phi[2]=0; // minority
        if ( y[i]==1 ) phi[3]=1; else phi[3]=0; // maverick
        phi[4]=1.0/3.0;                         // random
        if ( majority_first[i]==1 )             // follow first
            if ( y[i]==2 ) phi[5]=1; else phi[5]=0;
        else
            if ( y[i]==3 ) phi[5]=1; else phi[5]=0;
        
        // compute log( p_s * Pr(y_i|s )
        for ( j in 1:5 ) phi[j] = log(p[j]) + log(phi[j]);
        // compute average log-probability of y_i
        target += log_sum_exp( phi );
    }
}
```

