---
title: Dirichlet Distribution + Case Study
subtitle: Day 23
title-slide-attributes:
  data-background-color: "#e2583eff"
  data-slide-number: none
format: 
  revealjs:
    incremental: false
    scrollable: false
auto-stretch: true
editor_options: 
  chunk_output_type: inline
editor: 
  markdown: 
    wrap: 72
execute: 
  warning: false
  message: false
---

```{r}
#| echo: false
#| warning: false
#| message: false

library(countdown)
library(tidyverse)
library(tidybayes)
library(bayesrules)
library(janitor)
library(patchwork)
library(rstan)
library(rstanarm)
library(bayesplot)
library(broom.mixed)
library(ggrepel)

theme_set(theme_minimal(base_size = 16, base_family = "Atkinson Hyperlegible"))
clrs <- viridis::viridis(6, end = .75, option = "plasma")
```

## Motivating example: Inferring a child's strategy from the choice that they made

![](img/boxes-apparatus.png)


::: aside
Source: McElreath's [Stat Rethinking](https://github.com/rmcelreath/stat_rethinking_2024) book and course
:::

##

![](img/boxes-1.png)

##

![](img/boxes-2.png)

## 

![](img/boxes-3.png)

##

![](img/boxes-4.png)

##

![](img/boxes-5.png)

##

![](img/boxes-6.png)

##

![](img/boxes-7.png)


## Majority First

![](img/boxes-majority-first.png)

## Minority First

![](img/boxes-minority-first.png)

## 

![](img/boxes-summary.png)

## Social conformity

- Do children copy the majority? If so, how does this develop? 
- Problem: can't observe strategy, only choice
- Majority choice is consistent with many strategies
    - Randomly choose tube (p=1/3)
    - Randomly choose tube that was successful (p=1/2)

# Data generating process vs GLM

##

```{r}
Boxes <- read_delim("https://raw.githubusercontent.com/rmcelreath/rethinking/refs/heads/master/data/Boxes.csv")

Boxes
```

## Observable (choice) seems correlated with `majority_first`, but is unobservable (strategy)?

1 = "unchosen", 2 = "majority", 3 = "minority"

```{r}
#| echo: false


ggplot(Boxes, aes(x = majority_first, fill = factor(y))) + 
  geom_bar() +
  scale_fill_viridis_d(end = .75, option = "plasma")
```

## Model setup

Y: 1 = "unchosen", 2 = "majority", 3 = "minority"

::::: columns
::: {.column width="50%"}
5 different strategies: 

  - Majority
  - Minority
  - Maverick (choose the one that nobody chose)
  - Random
  - Follow first: copy the color that was demonstrated first
:::

::: {.column width="50%" .fragment}
Know probabilities within each strategy:

- If Majority strategy, $P(Y=2) = 1$ 
- If Minority strategy, $P(Y=3) = 1$
- If Maverick strategy, $P(Y=1) = 1$
- If Random strategy, 
  $$P(Y=1) = P(Y=2) = P(Y=3) = 1/3$$
- If "follow first" strategy, let $X=x$ be the tube picked first. $P(Y=y) = 1$ for $y=x$. 
:::
::::

## Model setup

$$Y_i \sim \text{Categorical}(\theta)$$

Where $\theta$ is a vector of probabilities for each outcome $Y$.  

We've just talked through all possibilities for $P(Y|S=s)$, where $S$ indicates one of the strategies. There is also some probability for each of the strategies, $p_s$. 

Then, $\theta_i = P(Y_i) = \sum_{s=1}^5 p_s P(Y_i | S=s)$

Prior for $p_s$?

## Beta distribution

```{r}
#| echo: false
ggplot() +
  stat_function(
    geom = "area", 
    fun = \(x) dbeta(x, shape1 = 3, shape2 = 7), 
    n = 1000, fill = clrs[1]) +
  labs(x = "Probability or proportion", y = NULL, title = "Beta(3, 7)") 
```

## 10 Random Draws from Dirichlet(3,7)

```{r}
set.seed(110525)
brms::rdirichlet(n = 10, alpha = c(3, 7)) |> data.frame() |> 
    set_names(1:2) |> 
    mutate(total = `1` + `2`)
```

Dirichlet(3,7) = [Beta(3,7), Beta(7,3)]

## Dirichlet is multivariate Beta

```{r}
#| echo: false


brms::rdirichlet(n = 1e5, alpha = c(3, 7)) |> 
    data.frame() |> 
    set_names(c("alpha[1]", "alpha[2]")) |> 
    pivot_longer(everything()) |> 
    ggplot(aes(x = value, fill = name)) +
    geom_density(bounds = c(0, 1), color = NA) +
    scale_fill_manual(values = clrs[c(1, 2)], guide = "none") +
    labs(x = "Probability or proportion", y = NULL, title = "Dirichlet(3, 7)") +
    facet_wrap(vars(name))
```

## Random draws from Dirichlet(3, 7, 2):

```{r}
brms::rdirichlet(n = 3, alpha = c(3, 7, 2)) |> data.frame() |> 
    set_names(1:3) |> 
    mutate(total = `1` + `2` + `3`)
```

## Random draws from Dirichlet(3, 7, 2, 2, 9, 1):

```{r}
brms::rdirichlet(n = 3, alpha = c(3, 7, 2, 2, 9, 1)) |> data.frame() |> 
    set_names(1:6) |> 
    mutate(total = `1` + `2` + `3` + `4` + `5` + `6`)
```

## Dirichlet(3, 7, 2)

```{r}
#| echo: false


plot_dirichlet_3_7_2 <- withr::with_seed(1234, {
  brms::rdirichlet(n = 1e5, alpha = c(3, 7, 2)) |> 
    data.frame() |> 
    set_names(paste0("alpha[", 1:3, "]")) |> 
    pivot_longer(everything()) |> 
    ggplot(aes(x = value, fill = name)) +
    geom_density(bounds = c(0, 1), color = NA) +
    scale_x_continuous(breaks = seq(0, 1, by = 0.2)) +
    scale_fill_manual(values = clrs[c(1, 2, 4)], guide = "none") +
    labs(x = "Probability or proportion", y = NULL, title = "Dirichlet(3, 7, 2)") +
    facet_wrap(vars(name), scales = "free_y")
})
plot_dirichlet_3_7_2
```

## Columns are correlated with each other

```{r}
#| echo: false


library(GGally)
points_custom <- function(data, mapping, ...) {
  ggplot(data = data, mapping = mapping, ...) + 
    geom_point(...) + 
    scale_x_continuous(breaks = seq(0, 1, by = 0.2), limits = c(0, 1)) + 
    scale_y_continuous(breaks = seq(0, 1, by = 0.2), limits = c(0, 1)) 
}

dist_custom <- function(data, mapping, ...) {
  ggplot(data = data, mapping = mapping, ...) +
    geom_density(...) +
    aes(fill = "") +
    scale_x_continuous(breaks = seq(0, 1, by = 0.2), limits = c(0, 1)) 
}

cor_custom <- function(data, mapping, ...) {
  ggally_cor(data = data, mapping = mapping, ...) +
    theme_void()
}

scat_mat <- brms::rdirichlet(n = 1e4, alpha = c(3, 7, 2)) |> 
  data.frame() |> 
  set_names(paste0("alpha[", 1:3, "]")) |> 
  ggpairs(
    lower = list(continuous = wrap(points_custom, size = 0.2, alpha = 0.1, color = clrs[5])),
    upper = list(continuous = wrap(cor_custom, family = "Manrope")),
    diag = list(continuous = wrap(dist_custom, color = NA, bounds = c(0, 1)))
  ) +
  labs(title = "Dirichlet(3, 7, 2)", subtitle = "Scatterplot matrix of 1,000 random draws")
scat_mat[1, 1] <- scat_mat[1, 1] + scale_fill_manual(values = clrs[1], guide = "none")
scat_mat[2, 2] <- scat_mat[2, 2] + scale_fill_manual(values = clrs[2], guide = "none")
scat_mat[3, 3] <- scat_mat[3, 3] + scale_fill_manual(values = clrs[4], guide = "none")
scat_mat
```

##

```{r}
#| echo: false
#| eval: false
library(ggtern)
# First triangle: random points
withr::with_seed(1234, {
  draws_3_7_2 <- brms::rdirichlet(n = 1e5, alpha = c(3, 7, 2)) |> 
    data.frame() |> 
    set_names(c("x", "y", "z"))
})

tern1 <- draws_3_7_2 |> 
  ggtern(aes(x = x, y = y, z = z)) +
  geom_point(size = 0.2, alpha = 0.1, color = clrs[5]) +
  scale_L_continuous(breaks = 0:5 / 5, labels = 0:5 / 5, name = "alpha[1]") +
  scale_T_continuous(breaks = 0:5 / 5, labels = 0:5 / 5, name = "alpha[2]") +
  scale_R_continuous(breaks = 0:5 / 5, labels = 0:5 / 5, name = "alpha[3]")


# Second triangle: actual densities
# Plotting the results from ddirichlet() is more difficult than using dbeta() or
# dnorm() or other univariate distributions. We can't just use geom_function().
# Instead, we need to generate a dataset of all possible combinations of the
# three columns (x, y, and z here), keep only the rows where they sum to one,
# and then find the probability density values for those rows with ddirichlet().
# It's a complex process, but it works :shrug:

# Create a sequence of values for x, y, and z
values <- seq(0, 1, by = 0.005)

# Generate all possible combinations of x, y, and z that sum to 1
df <- expand.grid(x = values, y = values, z = values) |>
  filter(x + y + z == 1) |> 
  rowwise() |>
  mutate(density = pmap_dbl(
    list(x, y, z),
    ~ brms::ddirichlet(
      as.numeric(c(..1, ..2, ..3)),
      alpha = c(3, 7, 2)
    )
  )) |> 
  filter(!is.nan(density))

tern2 <- ggtern(data = df, aes(x = x, y = y, z = z)) +
  geom_point(aes(color = density)) +
  # Mess with the breaks so that the gradient is more visible (basically flatten
  # super high values)
  scale_color_gradientn(
    colors = clrs[5:1], 
    values = scales::rescale(x = c(0, 1, 3, 8, 13), from = c(0, 13)),
    guide = "none"
  ) +
  scale_L_continuous(breaks = 0:5 / 5, labels = 0:5 / 5, name = "alpha[1]") +
  scale_T_continuous(breaks = 0:5 / 5, labels = 0:5 / 5, name = "alpha[2]") +
  scale_R_continuous(breaks = 0:5 / 5, labels = 0:5 / 5, name = "alpha[3]") 
  

# ggtern objects don't work with {patchwork} or gridExtra::grid.arrange() or
# {cowplot} or any of the plot-combining packages, but {ggtern} comes with its
# own version of grid.arrange(), so we can use that
ggtern::grid.arrange(tern1, tern2, ncol = 2)
```

## Dirichlet distribution 

Let $\vec{\theta} = (\theta_1, ... \theta_k)$ be a random vector of length $K \ge 2$, where each element $\theta_i > 0$ and $\sum \theta_i = 1$. The **Dirichlet model** with concentration parameter $\vec{\alpha} = (\alpha_1, ..., \alpha_k)$ is: 

$$\vec{\theta} \sim \text{Dirichlet}(\vec{\alpha})$$

$$f(\vec{\theta}) = \frac{1}{B(\vec{\alpha})} \prod_{i=1}^K \theta_i^{\alpha_i - 1}$$

where $B(\vec{\alpha})$ is the multivariate Beta function $B(\vec{\alpha}) = \frac{\prod \Gamma(\alpha_i)}{\Gamma(\alpha_0)}$ and $\alpha_0 = \sum \alpha_i$.

When $k=2$, the Dirichlet distribution simplifies to the Beta($\alpha_1, \alpha_2$). 

## Dirichlet distribution is conjugate for categorical/multinomial distribution

$$p \sim \text{Dirichlet}(\alpha_1, \alpha_2, ..., \alpha_k)$$

$$Y | p \sim \text{Categorical}(p)\text{ or Multinomial}(p)$$

and let $c_i$ be the number of occurrences of category $i$ in $Y$. Then:

$$p | Y \sim \text{Dirichlet}(c_1 + \alpha_1, c_2 + \alpha_2, ..., c_k + \alpha_k)$$

## Prior: $p_s \sim Dirichlet(4, 4, 4, 4, 4)$

```{r}
#| echo: false


plot_dirichlet_45 <- withr::with_seed(1234, {
  brms::rdirichlet(n = 1e5, alpha = c(4, 4, 4, 4, 4)) |> 
    data.frame() |> 
    set_names(paste0("alpha[", 1:5, "]")) |> 
    pivot_longer(everything()) |> 
    ggplot(aes(x = value, fill = name)) +
    geom_density(bounds = c(0, 1), color = NA) +
    scale_x_continuous(breaks = seq(0, 1, by = 0.2)) +
    scale_fill_manual(values = clrs[1:5], guide = "none") +
    labs(x = "Probability or proportion", y = NULL, title = "Dirichlet(3, 7, 2)") +
    facet_wrap(vars(name), scales = "free_y")
})
plot_dirichlet_45
```

## Stan Model for Strategies

```{r}
Boxes_model <- "data{
    int N;
    int y[N];
    int majority_first[N];
}
parameters{
    simplex[5] p;
}
model{
    vector[5] phi;
    
    // prior
    p ~ dirichlet( rep_vector(4,5) );
    
    // probability of data
    for ( i in 1:N ) {
        if ( y[i]==2 ) phi[1]=1; else phi[1]=0; // majority
        if ( y[i]==3 ) phi[2]=1; else phi[2]=0; // minority
        if ( y[i]==1 ) phi[3]=1; else phi[3]=0; // maverick
        phi[4]=1.0/3.0;                         // random
        if ( majority_first[i]==1 )             // follow first
            if ( y[i]==2 ) phi[5]=1; else phi[5]=0;
        else
            if ( y[i]==3 ) phi[5]=1; else phi[5]=0;
        
        // compute log( p_s * Pr(y_i|s )
        for ( j in 1:5 ) phi[j] = log(p[j]) + log(phi[j]);
        // compute average log-probability of y_i
        target += log_sum_exp( phi );
    }
}"
```

## Fit the model

```{r}
#| eval: false


data_list = list(
  N = nrow(Boxes),
  y = Boxes$y,
  majority_first = Boxes$majority_first
)

model_fit <- stan(model_code = Boxes_model, 
                  data = data_list, 
                  chains = 4, 
                  iter = 2*5000, 
                  seed = 110525)


```

## Diagnostics

```{r}
#| echo: false

load("23-boxes-model.rda")
```

```{r}
mcmc_trace(model_fit)
```

## P(Strategy)

```{r}
mcmc_dens(model_fit)
```
